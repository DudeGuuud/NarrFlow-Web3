大家好 我的项目是Narr Flow

NARRFLOW是一个在sui区块链上的去中心化的协作小说创作平台，可以让用户共同参与创作小说并获得代币奖励，将创作自由与社区共识机制相结合。

NARRFLOW和以往web2的创作模式不同，在过去我们看到的小说甚至文化产业的电影和游戏，剧本都经由中心化的个体作家，出版社，一套审查机制等流程才能进入到人们的视野里，有创作想法的个体是无法用简单的方式把自己的创意表达出来的。但是NARRFLOW可以弥补这一点，NARRFLOW通过结合社区的共识机制让用户全程平等的参与创作，然后进行投票来票选出最具创意和质量的内容来保存到区块链上供所有感兴趣的人去查阅。NARRFLOW用这种方式可以增加文化资产在区块链的流动性

NARRFLOW的核心功能是
1.协同创作 用户可以全程参与到小说的创作 包括小说的名字和所有内容 共同决定小说的剧情走向
2.投票机制 社区投票选出最佳小说内容提案，以确保最具共识的内容胜选。
3.代币奖励 参与到创作的用户将获得Narr token的奖励
4.在链上 获胜的提案内容会永久存储在sui上归档并提供查阅

下面是NARRFLOW的工作流程
第零张
用户会在前端先对小说的名称进行投票，前端统计完毕后会把胜选的名称写入区块链，然后进行下一轮关于正文第一段的投票，投票完成后进入第二段正文投票，以此类推，当正文段落数满10归档后，进入下一本书重新开始循环这个流程。前端可以实时查询到当前链上的内容

第一张
系统部署完成后，管理员会创建一个全局唯一的 StoryBook 对象。
初始状态下，没有书籍，当前活跃索引为 0。
然后，前端对新书的书名的提案投票流程开始。
每本书都有一个段落：vector<Paragraph>，用于存储所有段落。
通过 current_book_index 找到当前正在协作的书籍。
vector::borrow_mut 获取一个可变引用，并准备写入段落。

第二章
接着前端开始投票选出书的标题 然后 创建一个新的 Book 对象，其中包含获胜书名和作者信息
新书将添加到 books 数组的末尾，current_book_index 会指向它。更新当前活跃的书籍索引

第三章
每次添加段落，就是把新段落写入 StoryBook 里当前活跃书的 paragraphs数组。
链上数据结构始终保持最新，前端查询时能实时看到所有段落。
归档后自动切换新书，流程循环。
归档的话就是最后当段落数达到设定的阈值后，确保当前图书状态为未归档
book_ref.status 变为“已存档”，重置当前活跃图书索引

在未来

为了防止公共对象引发的安全问题，签名交易的逻辑将在后端的私有合约和账户中执行。
为了减少存储的Gas费用，未来会将文章转换为电子文档并存储在Walrus中。
为了防止用户恶意提交offensive的内容，将结合审核机制，确保Narr Flow创作的质量。
